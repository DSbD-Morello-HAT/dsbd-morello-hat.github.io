<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>DSbD Morello-HAT :: Towards a better memory management API - Part 1</title>
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
</head>

<body>
  
  <header class="d-flex align-items-center nav-bg sticky-top">
    <nav class="navbar navbar-expand-md navbar-fixed-top navbar-light bg-light nav-menu">
      <div class="container">

        <div id="logo">
          <a class="navbar-brand" href="../index.html"> <img src="../images/morello-hat-logo-no-baseline.png" class="d-inline-block" alt="Morello-HAT" id="logo">
          </a>
        </div>

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
          <ul class="navbar-nav" id="nav-inner">
            <li class="nav-item"> <a class="nav-link" href="../">Home</a></li>
            <li class="nav-item"> <a class="nav-link" href="../about.html">About</a></li>
            <li class="nav-item"> <a class="nav-link" href="../contact.html">Contact</a></li>
            <li class="nav-item"> <a class="nav-link" href="../posts.html">Posts</a></li>
          </ul>
        </div>
      </div>
    </nav>
  </header>

  <main role="main" class="container container-fluid">
    <div class="content">
      <h1>Towards a better memory management API - Part 1</h1>
      <div class="info">
    Posted on November  6, 2023
    
        by Cristian Urlea
    
</div>

<h2 id="abstract">Abstract</h2>
<p>Currently, the Morello stack supports C and C++ and as such, the capability API is very low-level and pointer-oriented. There are, however, many promising modern languages with fast-growing popularity (e.g.Â Go, Rust, Dart, etc.) that are not pointer-based and have different type systems and memory management strategies.</p>
<p>This raises the question of how to best support such languages such languages on CHERI-extended architectures, and in particular if we can design better APIs for memory management such that these languages can make better use of CHERI capabilities.</p>
<p>In this post we will go over some of the design considerations hiding behind this question, and attempt to lay the groundwork for better memory management APIs.</p>
<h2 id="what-is-cheri">What is CHERI?</h2>
<p>The CHERI ISA extension provides strong memory protection features which allow historically memory-unsafe programming languages, such as C and C++, to provide more protection against memory based attacks.</p>
<p>In CHERI, pointers are replaced by capabilities which include not only the address in memory being pointed to, but also additional metadata such: the allowable bounds, permissions which enable the loading/storing of regular/other capabilities and the execution of code, object tags, and a validity tag.</p>
<center>
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Morello Capability Layout Pages: 1 -->
<svg width="397pt" height="73pt" viewBox="0.00 0.00 397.00 73.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 69)">
<title>Morello Capability Layout</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-69 393,-69 393,4 -4,4"></polygon>
<!-- MemoryLayout -->
<g id="node1" class="node">
<title>MemoryLayout</title>
<polygon fill="none" stroke="black" points="8.5,-41.5 8.5,-60.5 95.5,-60.5 95.5,-41.5 8.5,-41.5"></polygon>
<text text-anchor="start" x="11.5" y="-47.9" font-family="Arial" font-size="12.00">Tag (1 bit)</text>
<polygon fill="none" stroke="black" points="8.5,-22.5 8.5,-41.5 95.5,-41.5 95.5,-22.5 8.5,-22.5"></polygon>
<text text-anchor="start" x="11.5" y="-28.9" font-family="Arial" font-size="12.00">Perms (16 bits)</text>
<polygon fill="none" stroke="black" points="95.5,-22.5 95.5,-41.5 211.5,-41.5 211.5,-22.5 95.5,-22.5"></polygon>
<text text-anchor="start" x="98.5" y="-28.9" font-family="Arial" font-size="12.00">Object Type (18 bits)</text>
<polygon fill="none" stroke="black" points="211.5,-22.5 211.5,-41.5 305.5,-41.5 305.5,-22.5 211.5,-22.5"></polygon>
<text text-anchor="start" x="214.5" y="-28.9" font-family="Arial" font-size="12.00">Bounds (20 bits)</text>
<polygon fill="none" stroke="black" points="305.5,-22.5 305.5,-41.5 381.5,-41.5 381.5,-22.5 305.5,-22.5"></polygon>
<text text-anchor="start" x="308.5" y="-28.9" font-family="Arial" font-size="12.00">Flags (8 bits)</text>
<polygon fill="none" stroke="black" points="8.5,-3.5 8.5,-22.5 381.5,-22.5 381.5,-3.5 8.5,-3.5"></polygon>
<text text-anchor="start" x="149.5" y="-9.9" font-family="Arial" font-size="12.00">Address (64 bits)</text>
</g>
</g>
</svg>

</center>
<center>
<b>Figure 1.</b> Morello Capability Layout
</center>
<p>The additional metadata can be accessed from C using a number of compiler builtin functions exposed by the compiler.
The cheri-port of the LLVM compiler, for example, exposes the following accessor builtins.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_getlen</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">         __builtin_cheri_length_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_getbase</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">        __builtin_cheri_base_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_getoffset</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">      __builtin_cheri_offset_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_getaddress</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">     __builtin_cheri_address_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_getperm</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">        __builtin_cheri_perms_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_getsealed</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">      __builtin_cheri_sealed_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_gettag</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">         __builtin_cheri_tag_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_gettype</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">        __builtin_cheri_type_get</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_andperm</span><span class="op">(</span><span class="pp">x</span><span class="op">,</span><span class="pp"> y</span><span class="op">)</span><span class="pp">     __builtin_cheri_perms_and</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">(</span><span class="pp">y</span><span class="op">))</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_clearperm</span><span class="op">(</span><span class="pp">x</span><span class="op">,</span><span class="pp"> y</span><span class="op">)</span><span class="pp">   __builtin_cheri_perms_and</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">~(</span><span class="pp">y</span><span class="op">))</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_cleartag</span><span class="op">(</span><span class="pp">x</span><span class="op">)</span><span class="pp">       __builtin_cheri_tag_clear</span><span class="op">((</span><span class="pp">x</span><span class="op">))</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_incoffset</span><span class="op">(</span><span class="pp">x</span><span class="op">,</span><span class="pp"> y</span><span class="op">)</span><span class="pp">   __builtin_cheri_offset_increment</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">(</span><span class="pp">y</span><span class="op">))</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_setoffset</span><span class="op">(</span><span class="pp">x</span><span class="op">,</span><span class="pp"> y</span><span class="op">)</span><span class="pp">   __builtin_cheri_offset_set</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">(</span><span class="pp">y</span><span class="op">))</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_setaddress</span><span class="op">(</span><span class="pp">x</span><span class="op">,</span><span class="pp"> y</span><span class="op">)</span><span class="pp">  __builtin_cheri_address_set</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">(</span><span class="pp">y</span><span class="op">))</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_seal</span><span class="op">(</span><span class="pp">x</span><span class="op">,</span><span class="pp"> y</span><span class="op">)</span><span class="pp">        __builtin_cheri_seal</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">(</span><span class="pp">y</span><span class="op">))</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define cheri_unseal</span><span class="op">(</span><span class="pp">x</span><span class="op">,</span><span class="pp"> y</span><span class="op">)</span><span class="pp">      __builtin_cheri_unseal</span><span class="op">((</span><span class="pp">x</span><span class="op">),</span><span class="pp"> </span><span class="op">(</span><span class="pp">y</span><span class="op">))</span></span></code></pre></div>
<center>
<b>Listing 1.</b> Capability Accessors in C
</center>
<h2 id="where-does-memory-come-from">Where does memory come from?</h2>
<p>If we are to propose a different approach to memory management, we must first understand the exact role of each component in the system. To that end, how exactly does an application acquire memory?</p>
<p>At a high level, we normally think of memory allocation in terms of an applicationâs interaction with the stack and heap, however this picture is incomplete. A part of the applicationâs memory needs to be allocated before execution can even begin, and this is the task of the dynamic loader.</p>
<h3 id="the-dynamic-loader">The Dynamic Loader</h3>
<p>Whenever a new application is to be executed, the dynamic loader will create a few allocations which serve to hold the executable code, as storage for global variables, and one or more stack areas, depending on the number of threads to be executed as part of the applicationâs process.</p>
<div>
<center>
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="328pt" height="130pt" viewBox="0.00 0.00 328.04 130.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 126)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-126 324.04,-126 324.04,4 -4,4"></polygon>
<!-- DynamicLoader -->
<g id="node1" class="node">
<title>DynamicLoader</title>
<ellipse fill="lightblue" stroke="black" cx="64.02" cy="-46" rx="64.04" ry="18"></ellipse>
<text text-anchor="middle" x="64.02" y="-42.9" font-family="Arial" font-size="12.00">Dynamic Loader</text>
</g>
<!-- MemorySpace -->
<g id="node2" class="node">
<title>MemorySpace</title>
<polygon fill="lightgrey" stroke="transparent" points="320.04,-122 198.04,-122 198.04,0 320.04,0 320.04,-122"></polygon>
<polygon fill="lightgreen" stroke="transparent" points="199.04,-61 199.04,-121 319.04,-121 319.04,-61 199.04,-61"></polygon>
<text text-anchor="start" x="243.54" y="-87.9" font-family="Arial" font-size="12.00">Stack</text>
<polygon fill="lightyellow" stroke="transparent" points="199.04,-31 199.04,-61 319.04,-61 319.04,-31 199.04,-31"></polygon>
<text text-anchor="start" x="227.04" y="-42.9" font-family="Arial" font-size="12.00">Client Code</text>
<polygon fill="lightyellow" stroke="transparent" points="199.04,-1 199.04,-31 319.04,-31 319.04,-1 199.04,-1"></polygon>
<text text-anchor="start" x="224.04" y="-12.9" font-family="Arial" font-size="12.00">Library Code</text>
<polygon fill="none" stroke="black" points="198.04,0 198.04,-122 320.04,-122 320.04,0 198.04,0"></polygon>
</g>
<!-- DynamicLoader&#45;&gt;MemorySpace -->
<g id="edge1" class="edge">
<title>DynamicLoader:e-&gt;MemorySpace:w</title>
<path fill="none" stroke="black" d="M128.04,-46C137.66,-46 137.98,-52.76 146.04,-58 165.76,-70.83 169.78,-85.98 187.89,-89.99"></path>
<polygon fill="black" stroke="black" points="198.04,-91 187.64,-94.48 193.07,-90.5 188.09,-90.01 188.09,-90.01 188.09,-90.01 193.07,-90.5 188.54,-85.53 198.04,-91 198.04,-91"></polygon>
<text text-anchor="middle" x="163.04" y="-89" font-family="Arial" font-size="10.00">mmap()</text>
</g>
<!-- DynamicLoader&#45;&gt;MemorySpace -->
<g id="edge2" class="edge">
<title>DynamicLoader:e-&gt;MemorySpace:w</title>
<path fill="none" stroke="black" d="M128.04,-46C136.05,-46 138.03,-45.22 146.04,-45 161.15,-44.58 164.94,-44.58 180.04,-45 183.3,-45.09 185.55,-45.27 187.63,-45.46"></path>
<polygon fill="black" stroke="black" points="198.04,-46 187.82,-49.97 193.05,-45.74 188.06,-45.48 188.06,-45.48 188.06,-45.48 193.05,-45.74 188.29,-40.98 198.04,-46 198.04,-46"></polygon>
<text text-anchor="middle" x="163.04" y="-48" font-family="Arial" font-size="10.00">mmap()</text>
</g>
<!-- DynamicLoader&#45;&gt;MemorySpace -->
<g id="edge3" class="edge">
<title>DynamicLoader:e-&gt;MemorySpace:w</title>
<path fill="none" stroke="black" d="M128.04,-46C140.68,-46 135.07,-30.26 146.04,-24 163.02,-14.31 171.61,-15.23 187.63,-15.79"></path>
<polygon fill="black" stroke="black" points="198.04,-16 187.95,-20.3 193.04,-15.9 188.04,-15.8 188.04,-15.8 188.04,-15.8 193.04,-15.9 188.13,-11.3 198.04,-16 198.04,-16"></polygon>
<text text-anchor="middle" x="163.04" y="-27" font-family="Arial" font-size="10.00">mmap()</text>
</g>
</g>
</svg>

</center>
<center>
<b>Figure 1.</b> Capability Accessors in C
</center>
</div>
<p>The dynamic loader will also search for the libraries required to start the application in various entries contained within the <code>LD_PATH</code> environment variable and load these into the allocated memory. The allocations are obtained from the operating system using the <code>mmap()</code> system call. This takes a number of parameters:</p>
<div>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>mmap<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>addr<span class="op">,</span> <span class="dt">size_t</span> length<span class="op">,</span> <span class="dt">int</span> prot<span class="op">,</span> <span class="dt">int</span> flags<span class="op">,</span> <span class="dt">int</span> fd<span class="op">,</span> off_t offset<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> munmap<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>addr<span class="op">,</span> <span class="dt">size_t</span> length<span class="op">);</span></span></code></pre></div>
<center>
<b>Listing 2.</b> Syscalls: <code>mmap()</code>, âmunmap()`.
</center>
</div>
<p>The second of these parameters, <code>int prot</code>, specifies how the new memory allocation can be used:</p>
<div>
<div class="sourceCode" id="cb3"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="in">    |------------|---------------------------|</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="in">    | PROT_EXEC  | Pages may be executed.    |</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="in">    |------------|---------------------------|</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="in">    | PROT_READ  | Pages may be written.     |</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="in">    |------------|---------------------------|</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="in">    | PROT_WRITE | Pages may be written.     |</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="in">    |------------|---------------------------|</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="in">    | PROT_NONE  | Pages may not be accessed.|</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="in">    |------------|---------------------------| </span></span></code></pre></div>
<center>
<b>Listing 3.</b> The <code>prot</code> parameter to <code>mmap(addr, prot, ...)</code>.
</center>
</div>
<p>The allocation into which the executable code is loaded needs to be provisioned using <code>PROT_EXEC | PROT_WRITE | PROT_READ</code> which would allow the dynamic loader to first write the executable code, and the execute it. The allocation used as the stack however, only requires <code>PROT_WRITE | PROT_READ</code>.</p>
<h3 id="the-stack-allocator">The Stack Allocator</h3>
<p>As an application executes, memory is continuously allocated and de-allocated on the stack, but what really drives this process and what can say about it?</p>
<p>One important aspect is that stack allocation is entirely automatic: memory is acquired and released as dictated by the applicable function <strong>calling convention</strong>, and thus there is very little that can go wrong, aside from running out of memory.</p>
<div>
<center>
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Function Call Pages: 1 -->
<svg width="412pt" height="268pt" viewBox="0.00 0.00 412.00 268.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 264)">
<title>Function Call</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-264 408,-264 408,4 -4,4"></polygon>
<g id="clust2" class="cluster">
<title>cluster_stacks</title>
</g>
<g id="clust3" class="cluster">
<title>cluster_stack_before</title>
<text text-anchor="middle" x="99" y="-52.3" font-family="Times,serif" font-size="14.00">Stack layout (before)</text>
</g>
<g id="clust4" class="cluster">
<title>cluster_stack_after</title>
<text text-anchor="middle" x="308" y="-23.8" font-family="Times,serif" font-size="14.00">Stack layout (after)</text>
</g>
<!-- Caller -->
<g id="node1" class="node">
<title>Caller</title>
<polygon fill="lightblue" stroke="lightblue" points="165,-260 111,-260 111,-224 165,-224 165,-260"></polygon>
<text text-anchor="middle" x="138" y="-238.9" font-family="Arial" font-size="12.00">Caller</text>
</g>
<!-- StackPointer -->
<g id="node2" class="node">
<title>StackPointer</title>
<polygon fill="none" stroke="black" points="164,-159.5 24,-159.5 24,-75.5 164,-75.5 164,-159.5"></polygon>
<polygon fill="orange" stroke="transparent" points="32,-136.5 32,-155.5 156,-155.5 156,-136.5 32,-136.5"></polygon>
<polygon fill="none" stroke="black" points="32,-136.5 32,-155.5 156,-155.5 156,-136.5 32,-136.5"></polygon>
<text text-anchor="start" x="58" y="-142.9" font-family="Arial" font-size="12.00">Stack Pointer</text>
<polygon fill="lightblue" stroke="transparent" points="32,-117.5 32,-136.5 156,-136.5 156,-117.5 32,-117.5"></polygon>
<polygon fill="none" stroke="black" points="32,-117.5 32,-136.5 156,-136.5 156,-117.5 32,-117.5"></polygon>
<text text-anchor="start" x="35" y="-123.9" font-family="Arial" font-size="12.00">Caller Local Variables</text>
<polygon fill="lightblue" stroke="transparent" points="32,-98.5 32,-117.5 156,-117.5 156,-98.5 32,-98.5"></polygon>
<polygon fill="none" stroke="black" points="32,-98.5 32,-117.5 156,-117.5 156,-98.5 32,-98.5"></polygon>
<text text-anchor="start" x="52" y="-104.9" font-family="Arial" font-size="12.00">Return Address</text>
<polygon fill="lightblue" stroke="transparent" points="32,-79.5 32,-98.5 156,-98.5 156,-79.5 32,-79.5"></polygon>
<polygon fill="none" stroke="black" points="32,-79.5 32,-98.5 156,-98.5 156,-79.5 32,-79.5"></polygon>
<text text-anchor="start" x="45.5" y="-85.9" font-family="Arial" font-size="12.00">Caller Parameters</text>
</g>
<!-- Caller&#45;&gt;StackPointer -->
<!-- Callee -->
<g id="node3" class="node">
<title>Callee</title>
<polygon fill="lightgreen" stroke="lightgreen" points="313,-260 259,-260 259,-224 313,-224 313,-260"></polygon>
<text text-anchor="middle" x="286" y="-238.9" font-family="Arial" font-size="12.00">Callee</text>
</g>
<!-- Caller&#45;&gt;Callee -->
<g id="edge3" class="edge">
<title>Caller-&gt;Callee</title>
<path fill="none" stroke="black" d="M165.17,-242C192.92,-242 220.66,-242 248.4,-242"></path>
<polygon fill="black" stroke="black" points="248.62,-245.5 258.62,-242 248.62,-238.5 248.62,-245.5"></polygon>
</g>
<!-- StackAfter -->
<g id="node4" class="node">
<title>StackAfter</title>
<polygon fill="none" stroke="black" points="379.5,-188 236.5,-188 236.5,-47 379.5,-47 379.5,-188"></polygon>
<polygon fill="orange" stroke="transparent" points="245,-164.5 245,-183.5 372,-183.5 372,-164.5 245,-164.5"></polygon>
<polygon fill="none" stroke="black" points="245,-164.5 245,-183.5 372,-183.5 372,-164.5 245,-164.5"></polygon>
<text text-anchor="start" x="272.5" y="-170.9" font-family="Arial" font-size="12.00">Stack Pointer</text>
<polygon fill="lightgreen" stroke="transparent" points="245,-145.5 245,-164.5 372,-164.5 372,-145.5 245,-145.5"></polygon>
<polygon fill="none" stroke="black" points="245,-145.5 245,-164.5 372,-164.5 372,-145.5 245,-145.5"></polygon>
<text text-anchor="start" x="248" y="-151.9" font-family="Arial" font-size="12.00">Callee Local Variables</text>
<polygon fill="lightgreen" stroke="transparent" points="245,-126.5 245,-145.5 372,-145.5 372,-126.5 245,-126.5"></polygon>
<polygon fill="none" stroke="black" points="245,-126.5 245,-145.5 372,-145.5 372,-126.5 245,-126.5"></polygon>
<text text-anchor="start" x="266.5" y="-132.9" font-family="Arial" font-size="12.00">Return Address</text>
<polygon fill="lightgreen" stroke="transparent" points="245,-107.5 245,-126.5 372,-126.5 372,-107.5 245,-107.5"></polygon>
<polygon fill="none" stroke="black" points="245,-107.5 245,-126.5 372,-126.5 372,-107.5 245,-107.5"></polygon>
<text text-anchor="start" x="258.5" y="-113.9" font-family="Arial" font-size="12.00">Callee Parameters</text>
<polygon fill="lightblue" stroke="transparent" points="245,-88.5 245,-107.5 372,-107.5 372,-88.5 245,-88.5"></polygon>
<polygon fill="none" stroke="black" points="245,-88.5 245,-107.5 372,-107.5 372,-88.5 245,-88.5"></polygon>
<text text-anchor="start" x="249.5" y="-94.9" font-family="Arial" font-size="12.00">Caller Local Variables</text>
<polygon fill="lightblue" stroke="transparent" points="245,-69.5 245,-88.5 372,-88.5 372,-69.5 245,-69.5"></polygon>
<polygon fill="none" stroke="black" points="245,-69.5 245,-88.5 372,-88.5 372,-69.5 245,-69.5"></polygon>
<text text-anchor="start" x="266.5" y="-75.9" font-family="Arial" font-size="12.00">Return Address</text>
<polygon fill="lightblue" stroke="transparent" points="245,-50.5 245,-69.5 372,-69.5 372,-50.5 245,-50.5"></polygon>
<polygon fill="none" stroke="black" points="245,-50.5 245,-69.5 372,-69.5 372,-50.5 245,-50.5"></polygon>
<text text-anchor="start" x="260" y="-56.9" font-family="Arial" font-size="12.00">Caller Parameters</text>
</g>
<!-- Callee&#45;&gt;StackAfter -->
</g>
</svg>

</center>
<center>
<b>Figure 2.</b> Stack allocation is driven by function calls.
</center>
</div>
<p>The programmer can indirectly control how the stack allocator behaves. As memory is allocated and de-allocated whenever functions are called, annotating the source-code with <code>inline</code> directives can reduce the frequency of these events.</p>
<p>Stack allocation is typically very quick. On most platforms, stack allocation and de-allocation can boil down to as little as a single instruction code fragments that simply increment or decrement the stack pointer.</p>
<h3 id="the-heap-allocator">The Heap Allocator</h3>
<p>When we talk about memory allocation in C, the first things that might spring to mind are the well known <code>malloc()</code> and <code>free()</code> functions. These give the programmer direct control of the heap allocation at all times.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>arr<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> <span class="dv">256</span><span class="op">;</span> <span class="co">// Size of the integer array</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Allocate memory for the integer array</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span>size <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Assign values to the elements of the array</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Free the allocated memory</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>arr<span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<center>
<b>Listing 4. </b>Typical <code>malloc(); use(); free()</code> cycle.
</center>
<p>Before we can store anything on the heap, a sufficiently large slice of memory must first be obtained with a call to <code>malloc()</code>. Once we are done with the allocation, a call to <code>free()</code> will return the slice of memory back to the allocator.
If for one reason or another, we end up needing to re-size an allocation, a simple call to <code>realloc()</code> is all that is needed.</p>
<p>One issue with such direct control over heap allocation is that we might forget to make the appropriate call to <code>free()</code>. If this happens sufficiently many times of over the lifetime of an execution, the system can run out of memory and crash.</p>
<p>Likewise, if a heap allocation is freed but still accessible through pointers that have not been cleared at the same time, this can lead to an exploitable <code>Use-After-Free</code> vulnerability.</p>
<p>Heap allocation is riddled with such corner cases and gotchas. Consider for a moment, what might happen if we executed the code in <strong>Listing 2</strong> immediately after that in <strong>Listing 1</strong>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>arr2<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    arr2 <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span>size <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// surprise?</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<center>
<b>Listing 5. </b> What happened here?
</center>
<p>A novice programmer might reasonably expect that <code>arr2</code> point to some fresh area of memory and thus be surprised to find that the values previously stored through <code>arr1</code> are now accessible again. While stack stack memory is cleared on allocation, the same does not normally hold true for allocations obtained through <code>malloc()</code>.</p>
<p>While it is possible to obtain a heap allocation with zeroed out memory, through a call to <code>calloc()</code>, that is not necessarily the most secure course of action.</p>
<p>If we are interested in preserving the <strong>integrity</strong> of our new allocation, then <code>calloc()</code> works well for that purpose as memory is zeroed out before a pointer to the allocation is obtained.</p>
<p>If on the other hand, we would be more interested in preserving <strong>privacy</strong>, that is to say that we are instead concerned with ensuring that the contents stored through <code>arr1</code> are never leaked to begin with, then that would call for an alternative implementation for the <code>free()</code> function, one which zeros out the memory before it is made available for re-allocation. Sadly no such function is made available through the standard memory allocation API.</p>
<h3 id="the-kernel">The Kernel</h3>
<p>For most use-cases, memory allocation via the stack and the standard library heap allocator is generally suited, however, there are circumstances where these do not provide enough control to the programmer.</p>
<p>Precise control over memory allocation may be desirable for security or performance reasons. The Linux kernel, for example, exposes a number of system calls such as: <code>mmap()</code>, <code>mbind()</code>, <code>madvise()</code>, <code>mprotect()</code> and <code>mlock()</code>, which can be used to fine-tune many of the rich memory allocation policy features available.</p>
<p>The <code>mmap()</code> system call, accepts an <code>int prot</code> argument which may used to specify whether or not the returned memory mapping allows the contents to be read, written or executed.</p>
<p>This feature is implemented on some platforms using the <strong>No-Execute Bit (NX bit)</strong>, a crucial security feature of most modern architectures that prevents the execution of code stored in particular regions of memory designated for data storage.</p>
<p>This mechanism prevents certain common security vulnerabilities such as the use of <code>buffer overflow</code> and <code>code injection</code> attacks to trigger the execution of malicious code. The standard memory allocation and de-allocation functions such as <code>malloc()</code> and <code>free()</code> do not expose enough functionality to make use of the <code>NX bit</code>.</p>
<p>The <code>mbind()</code> and <code>madvise()</code> syscalls can be used to improve performance, the former being used to tweak the non-uniform memory access policy while the latter allows a running program to inform the kernel that a particular memory access pattern is likely to occur in the near future, thus allowing the kernel to make better use of prefetching.</p>
<h3 id="memory-management-automation">Memory Management Automation</h3>
<h4 id="garbage-collection">Garbage Collection</h4>
<p>Many programming languages make use of Garbage Collection (GC), which provides automatic (heap) memory management. Instead of giving the programmer explicit control over memory allocation, the system assumes that such events are to be implied by certain language constructs, such as the <code>new</code> keyword in Java.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Memory allocation for obj1</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    MyClass obj1 <span class="op">=</span> <span class="kw">new</span> <span class="fu">MyClass</span><span class="op">();</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span> <span class="co">// Possible deallocation for obj1</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> </span></code></pre></div>
<center>
<b>Listing 6. </b> The <code>new</code> keyword in Java allocates memory.
</center>
<p>Similarly, exact control over memory deallocation withheld from the programmer, and instead, the garbage collector runs periodically to free up any memory that can be safely determined to be no longer needed. In the example shown, <code>obj1</code> goes out of scope as soon as the function returns.</p>
<p>Automatically determining when it is safe to free memory can be a challenging task indeed. A simple GC implementation might scan the entire memory contents of an application for references to an allocation, and if none can be found, mark the allocation as being safe to reclaim. This strategy for GC is commonly known as <em>mark and sweep</em>.</p>
<p>In practice, a simple GC strategy as previously described will deliver fairly poor performance. Scanning the entire contents of an applicationâs memory for references can take some time, during which, the application typically needs to be prevented from executing such that race between it and the GC do not lead to an unsound state.</p>
<p>Fortunately, there are many improvements to this simple strategy that can be used in speed up garbage collection. Examples include <code>Concurrent GC</code> and <code>Generational GC</code>. What interests us more is the dependency of such strategies upon the structure and semantics of the programming language being used.</p>
<p>The <strong>Dart</strong> programming language, for example, makes use of both <strong>Strong</strong> and <strong>Weak</strong> references. The difference between the two is that the existence of a single <code>Strong References</code> to some object is sufficient to prevent the Dart GC from freeing the allocation, whereas the existence of any number of <code>Weak references</code> would not.</p>
<h4 id="tracking-ownership">Tracking Ownership</h4>
<h5 id="resource-acquisition-is-initialization">Resource Acquisition Is Initialization</h5>
<p>In languages such as C++ that do not have a garbage collector, it is desirable to avoid heap allocations CHERI</p>
<p>This is made possible by the fact that heap allocations can be related to stack allocations. If, for example, a single reference to some heap allocation exists within a particular functionâs stack frame, then whenever such a function returns, the stack shrinks and the reference disappears, allowing the associated heap allocation to be freed.</p>
<p>To this end, Rust implements an ownership model, which dictates that all memory allocations have exactly one owner, and that they must be released as soon as their owners are released.</p>
<p>Where Rust really shines is in its ability to keep track of heap allocations across function call boundaries.
Normally, one may thing that every heap allocation would have to be immediately freed upon exit from the scope where the allocation occurred. Fortunately, this is not the case. The type system in Rust implements a <code>borrow checker</code> and a <code>lifetime system</code> which relax these rules while preserving safety.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> foo(i<span class="op">:</span> <span class="op">&amp;</span><span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> answer <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    foo(y)<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<center>
<b>Listing 7. </b> Lifetimes in Rust.
</center>
<h5 id="reference-counting">Reference Counting</h5>
<p>As the <code>lifetime</code> mechanism in Rust is enforced at compile time, this presents a problem: it requires that memory allocations are used and freed in a Last-In-First-Out order, consistent with the operation of the stack and the borrow rules that apply. The requirement that every allocation have a single owner is particularly troublesome for certain types of application.</p>
<p>For situations where more flexibility is required, rust provides the <code>Rc&lt;T&gt;</code> type which provides a reference counting implementation, allowing for allocations with multiple owners which are safely freed when their owner count drops to zero.</p>

    </div>
  </main>

  <footer class="footer py-4 py-md-5 mt-5 bg-light">
    <div class="container py-4 py-md-5 px-4 px-md-3">
      <div class="row">

        <div class="col-sm-6 col-12 m-auto">
          Morello-HAT is
          <a href="https://gow.epsrc.ukri.org/NGBOViewGrant.aspx?GrantRef=EP/X015955/1" target="_blank">
            funded by UKRI-EPSRC
          </a> as part of
          <a href="https://www.dsbd.tech/" target="_blank">
            Digital Security by Design
          </a>
        </div>

        <div class="col-sm-3 col-6 m-auto">
          <a class="d-inline-flex align-items-center mb-2" href="https://www.ukri.org/councils/epsrc/">
            <img class="style-logo" src="../logos/ukri-logo.png" alt="ukri Logo">
          </a>
        </div>

      </div>
    </div>
  </footer>


  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>

</html>